# Java三大特性

## 封装

封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。

好处：

1. 可以彻底隐藏方法的内部实现，仅仅提供一个调用的方法给其他人，让其他使用这个类的人不需要关心是如何实现的，只要知道该如何调用就行。
2. 隐藏方法的内部实现的好处，可以让保留调用方法不变的同时，随意修改类的结构，而不影响其他人运行结果。
3. 封装还会分开类的属性，将类的属性分成私有属性和公共属性。私有属性仅供类自身调用，和公共属性也仅提供一个供外部调用的方法。
4. 按照软件的术语，良好的封装是能够减少耦合。

访问权限：

- public：接口访问权限。也就是说public修饰的成员方法，属性都是可以在任何地方所访问的。
- private: 类以外无法访问 。也就说private修饰的成员方法，属性都是只能在这个类中被访问，在类以外的地方，其他对象是无法访问到这个类里面的内容。
- protected: 继承访问权限。在说到继承访问权限之前，我们思考这样一个问题，我们有一个基类，是需要被继承的。基类中的成员属性，我们是希望能被继承的类所访问，那么我们是可以把他设定成public，但是一旦这样的话，除了这个继承的类，其他类也会访问到。这个显然不是我们所期望的事情，所以Java引入protected修饰符，来表示所修饰的部分是能被派生的类所访问的，同时他也能被同一包里面的其他类所访问。

## 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。

继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。

继承定义了类如何相互关联，共享特性。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。

继承的使用：

1. 子类拥有父类非private的属性和方法。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以重写父类的方法。

### 构造器

对于构造器而言，子类只能够被调用，而不能被继承。调用父类的构造方法时候super()。

构造器构建过程，从父类开始向子类一级一级地完成构建。当父类有默认构造器，子类不需要显示的引用父类的构造器，编译器会默认给子类调用父类的构造器；但是，如果父类没有默认构造器，就必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。

综上：**对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)**

### protected关键字

对于protected而言，它指明对类用户而言，它是private，但是对于任何继承这个类的子类而言或者其他任何位于同一个包的类而言，它却是可以访问的。

### 向上转型

将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。

### 慎用继承

继承存在的缺陷：

1. 父类变，子类就必须变。
2. 继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。
3. 继承是一种强耦合关系。

《Think in java》中提供了解决办法：**问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承**

## 多态

多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。

对于Java而言，它多态的实现机制遵循一个原则：**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法**

基于继承实现的多态可以总结如下：**对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同**

在继承链中对象方法的调用存在一个优先级：**this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)**