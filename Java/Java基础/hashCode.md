# hashCode

## hashCode的作用

在Java集合中有两类，一类是List，一类是Set,它们之间的区别就在于List集合中的元素师有序的，且可以重复，而Set集合中元素是无序不可重复的。对于List好处理，但是对于Set而言我们要如何来保证元素不重复呢？通过迭代来equals()是否相等。数据量小还可以接受，当数据量大的时候效率可想而知，hashCode提供了解决方案。

`public native int hashCode();`，它是一个本地方法，它的实现与本地机器有关。当需要向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置。这样处理，当存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。

综上，hashCode的作用是**寻域** （寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。

## hashCode与equals

在Java中hashCode的实现总是伴随着equals，，它们是紧密配合的，你要是自己设计了其中一个，就要设计另外一个。当然在多数情况下，这两个方法是不用我们考虑的，直接使用默认方法就可以帮助我们解决很多问题。但是在有些情况，我们必须要自己动手来实现它，才能确保程序更好的运作。

对于equal遵循如下规则：

- 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”
- 反射性：x.equals(x)必须返回是“true”
- 类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”
- 一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”

**注：** 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”

对于hashCode遵循如下规则：

- 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数
- 如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果
- 如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能

综上，两者的关联如下：【部分】

- 如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等
- 如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等

两者配合工作的流程：

- 判断两个对象的hashcode是否相等，若不等，则认为两个对象不等，完毕，若相等，则比较equals
- 若两个对象的equals不等，则可以认为两个对象不等，否则认为它们相等