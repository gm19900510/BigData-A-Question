> 目前 MVCC 设计没有统一的实现标准，因此 MySQL、Oracle、PostgreSQL 等其他数据库都有各自的实现，但各自的实现机制不尽相同。

可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。

MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说。不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

在 REPEATABLE READ 隔离级别下，MVCC 具体操作如下：
- SELECT
  InnoDB 会根据以下两个条件检查每行记录：
  - InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么在事务开始前已经存在的，要么是事务自身插入或者修改过的
  - 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除
  只有符合上述两个条件的记录，才会返回作为查询结果
- INSERT
  InnoDB 为新插入的每一行保存当前系统版本号作为行版本号
- DELETE
  InnoDB 为删除的每一行保存当前系统版本号作为行删除标识
- UPDATE
  InnoDB 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识

保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样的设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

MVCC 只在 REPEATABLE READ 和 READ COMMITED 两个隔离级别下工作。其他两个隔离级别都和 MVCC 不兼容，因为 READ UNCOMMITED 总是读取最新的数据行，而不是符合当前事务版本的数据行；而 SERIALIZABLE 则会对所有读取的行都加锁。